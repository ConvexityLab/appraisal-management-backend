/**
 * Conditional Logic Builder Implementation
 * Provides a fluent API for creating complex notification conditions
 */

import { AppEvent } from '../types/events';
import { NotificationContext, ConditionalFunction, FieldCondition, ConditionalLogicBuilder } from '../types/persistent-notifications';
import { Logger } from '../utils/logger';
import { DynamicCodeExecutionService, CodeExecutionContext } from './dynamic-code-execution.service';

export class NotificationConditionBuilder implements ConditionalLogicBuilder {
  private logger: Logger;
  private codeExecutionService: DynamicCodeExecutionService;

  constructor() {
    this.logger = new Logger('NotificationConditionBuilder');
    this.codeExecutionService = new DynamicCodeExecutionService({
      timeout: 5000,
      memoryLimit: 16 * 1024 * 1024 // 16MB
    });
  }

  field(path: string): FieldCondition {
    return new FieldConditionImpl(path);
  }

  and(...conditions: ConditionalFunction[]): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      return conditions.every(condition => {
        try {
          return condition(event, context);
        } catch (error) {
          this.logger.error('Condition evaluation failed in AND', { error });
          return false;
        }
      });
    };
  }

  or(...conditions: ConditionalFunction[]): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      return conditions.some(condition => {
        try {
          return condition(event, context);
        } catch (error) {
          this.logger.error('Condition evaluation failed in OR', { error });
          return false;
        }
      });
    };
  }

  not(condition: ConditionalFunction): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      try {
        return !condition(event, context);
      } catch (error) {
        this.logger.error('Condition evaluation failed in NOT', { error });
        return false;
      }
    };
  }

  custom(fn: ConditionalFunction): ConditionalFunction {
    return fn;
  }

  // Time-based conditions
  inTimeRange(startHour: number, endHour: number): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      const now = new Date();
      const hour = now.getHours();
      
      // Handle timezone if provided in context
      if (context?.timezone) {
        const userTime = new Date(now.toLocaleString("en-US", { timeZone: context.timezone }));
        return userTime.getHours() >= startHour && userTime.getHours() < endHour;
      }
      
      return hour >= startHour && hour < endHour;
    };
  }

  onWeekdays(): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      const dayOfWeek = new Date().getDay();
      return dayOfWeek >= 1 && dayOfWeek <= 5; // Monday = 1, Friday = 5
    };
  }

  onWeekends(): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      const dayOfWeek = new Date().getDay();
      return dayOfWeek === 0 || dayOfWeek === 6; // Sunday = 0, Saturday = 6
    };
  }

  // Context-based conditions
  forTenant(tenantId: string): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      return context?.tenantId === tenantId;
    };
  }

  forRole(role: string): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      return context?.userRole === role;
    };
  }

  forUser(userId: string): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      return context?.userId === userId;
    };
  }
}

class FieldConditionImpl implements FieldCondition {
  constructor(private path: string) {}

  private getValue(event: AppEvent, context?: NotificationContext): any {
    const paths = this.path.split('.');
    let current: any = { event, context, data: event.data };
    
    for (const path of paths) {
      if (current && typeof current === 'object' && path in current) {
        current = current[path];
      } else {
        return undefined;
      }
    }
    
    return current;
  }

  equals(value: any): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      const fieldValue = this.getValue(event, context);
      return fieldValue === value;
    };
  }

  notEquals(value: any): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      const fieldValue = this.getValue(event, context);
      return fieldValue !== value;
    };
  }

  greaterThan(value: number): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      const fieldValue = this.getValue(event, context);
      return typeof fieldValue === 'number' && fieldValue > value;
    };
  }

  lessThan(value: number): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      const fieldValue = this.getValue(event, context);
      return typeof fieldValue === 'number' && fieldValue < value;
    };
  }

  contains(value: string): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      const fieldValue = this.getValue(event, context);
      return typeof fieldValue === 'string' && fieldValue.includes(value);
    };
  }

  matches(pattern: string): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      const fieldValue = this.getValue(event, context);
      if (typeof fieldValue !== 'string') return false;
      
      try {
        return new RegExp(pattern).test(fieldValue);
      } catch (error) {
        return false;
      }
    };
  }

  in(values: any[]): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      const fieldValue = this.getValue(event, context);
      return values.includes(fieldValue);
    };
  }

  exists(): ConditionalFunction {
    return (event: AppEvent, context?: NotificationContext) => {
      const fieldValue = this.getValue(event, context);
      return fieldValue !== undefined && fieldValue !== null;
    };
  }
}

// Condition evaluator for string-based conditions
export class ConditionEvaluator {
  private logger: Logger;

  constructor() {
    this.logger = new Logger('ConditionEvaluator');
  }

  async evaluate(
    condition: string | ConditionalFunction, 
    event: AppEvent, 
    context?: NotificationContext
  ): Promise<boolean> {
    if (typeof condition === 'function') {
      try {
        return condition(event, context);
      } catch (error) {
        this.logger.error('Function condition evaluation failed', { error });
        return false;
      }
    }

    // Parse and evaluate string-based conditions
    return this.evaluateStringCondition(condition, event, context);
  }

  private evaluateStringCondition(
    condition: string, 
    event: AppEvent, 
    context?: NotificationContext
  ): boolean {
    // Create safe evaluation context
    const evalContext = {
      // Event data
      event,
      data: event.data,
      type: event.type,
      source: event.source,
      timestamp: event.timestamp,
      
      // Context data
      context,
      user: context,
      tenant: context ? { id: context.tenantId } : null,
      
      // Time helpers
      now: new Date(),
      hour: new Date().getHours(),
      dayOfWeek: new Date().getDay(),
      
      // Helper functions
      contains: (str: string, substr: string) => str && str.includes(substr),
      matches: (str: string, pattern: string) => {
        try {
          return str && new RegExp(pattern).test(str);
        } catch {
          return false;
        }
      },
      inTimeRange: (start: number, end: number) => {
        const hour = new Date().getHours();
        return hour >= start && hour < end;
      },
      isWeekday: () => {
        const day = new Date().getDay();
        return day >= 1 && day <= 5;
      },
      isWeekend: () => {
        const day = new Date().getDay();
        return day === 0 || day === 6;
      },
      
      // Array helpers
      length: (arr: any[]) => arr ? arr.length : 0,
      includes: (arr: any[], value: any) => arr && arr.includes(value),
      
      // Math helpers
      min: Math.min,
      max: Math.max,
      abs: Math.abs
    };

    try {
      return this.safeEval(condition, evalContext);
    } catch (error) {
      this.logger.error('String condition evaluation failed', { condition, error });
      return false;
    }
  }

  private safeEval(expression: string, context: any): boolean {
    // Create a safe evaluation function
    const keys = Object.keys(context);
    const values = keys.map(key => context[key]);
    
    try {
      // Use Function constructor with restricted scope
      const func = new Function(...keys, `"use strict"; return (${expression});`);
      const result = func(...values);
      return Boolean(result);
    } catch (error) {
      this.logger.error('Safe eval failed', { expression, error });
      return false;
    }
  }
}

// Pre-built condition helpers
export const Conditions = {
  // Value conditions
  highValue: (threshold: number = 1000000) => 
    (event: AppEvent) => (event.data as any).estimatedValue > threshold,
  
  criticalSeverity: () => 
    (event: AppEvent) => (event.data as any).severity === 'critical',
  
  highPriority: () => 
    (event: AppEvent) => (event.data as any).priority === 'high',

  // Time conditions
  businessHours: () => 
    (event: AppEvent, context?: NotificationContext) => {
      const hour = new Date().getHours();
      return hour >= 9 && hour < 17;
    },

  afterHours: () => 
    (event: AppEvent, context?: NotificationContext) => {
      const hour = new Date().getHours();
      return hour < 9 || hour >= 17;
    },

  weekdays: () => 
    (event: AppEvent, context?: NotificationContext) => {
      const day = new Date().getDay();
      return day >= 1 && day <= 5;
    },

  // Geographic conditions
  california: () => 
    (event: AppEvent) => {
      const address = (event.data as any).propertyAddress || '';
      return address.includes('CA') || address.includes('California');
    },

  // Role-based conditions
  forManagers: () => 
    (event: AppEvent, context?: NotificationContext) => {
      return context?.userRole === 'manager' || context?.userRole === 'admin';
    },

  forAppraisers: () => 
    (event: AppEvent, context?: NotificationContext) => {
      return context?.userRole === 'appraiser';
    },

  // Complex conditions
  urgentAfterHours: () => 
    (event: AppEvent, context?: NotificationContext) => {
      const hour = new Date().getHours();
      const isAfterHours = hour < 9 || hour >= 17;
      const isCritical = (event.data as any).severity === 'critical' || 
                        (event.data as any).priority === 'high';
      return isAfterHours && isCritical;
    },

  vipClient: (vipTenants: string[] = []) => 
    (event: AppEvent, context?: NotificationContext) => {
      return vipTenants.includes(context?.tenantId || '') ||
             ((event.data as any).clientId || '').startsWith('VIP-');
    }
};

  // Dynamic JavaScript Code Execution Methods
  
  /**
   * Execute custom JavaScript code as a condition
   * @param code - JavaScript code that returns a boolean
   * @param description - Optional description for debugging
   * @param timeout - Execution timeout (default: 5000ms)
   */
  javascript(code: string, description?: string, timeout?: number): ConditionalFunction {
    return async (event: any, context?: any) => {
      try {
        const executionContext: CodeExecutionContext = {
          event,
          context: context || {},
          rule: {},
          timestamp: new Date(),
          utils: {
            date: Date,
            math: Math,
            json: JSON,
            regex: RegExp,
            console: {
              log: (...args: any[]) => this.logger.debug('JS Condition log:', args),
              warn: (...args: any[]) => this.logger.warn('JS Condition warn:', args),
              error: (...args: any[]) => this.logger.error('JS Condition error:', args)
            }
          }
        };

        const result = await this.codeExecutionService.executeCode(
          code, 
          executionContext, 
          { timeout: timeout || 5000 }
        );

        if (!result.success) {
          this.logger.error('JavaScript condition execution failed', {
            description,
            error: result.error,
            codePreview: code.substring(0, 100)
          });
          return false;
        }

        // Ensure result is boolean
        return !!result.result;

      } catch (error) {
        this.logger.error('JavaScript condition error', { 
          error: error instanceof Error ? error.message : 'Unknown error',
          description 
        });
        return false;
      }
    };
  }

  /**
   * Execute a simple JavaScript expression (automatically wrapped in return statement)
   * @param expression - JavaScript expression that evaluates to boolean
   * @param description - Optional description
   */
  expression(expression: string, description?: string): ConditionalFunction {
    return async (event: any, context?: any) => {
      try {
        const executionContext: CodeExecutionContext = {
          event,
          context: context || {},
          rule: {},
          timestamp: new Date(),
          utils: {
            date: Date,
            math: Math,
            json: JSON,
            regex: RegExp,
            console: {
              log: (...args: any[]) => this.logger.debug('Expression log:', args),
              warn: (...args: any[]) => this.logger.warn('Expression warn:', args),
              error: (...args: any[]) => this.logger.error('Expression error:', args)
            }
          }
        };

        const result = await this.codeExecutionService.executeExpression(
          expression, 
          executionContext
        );

        if (!result.success) {
          this.logger.error('Expression condition execution failed', {
            description,
            error: result.error,
            expression
          });
          return false;
        }

        return !!result.result;

      } catch (error) {
        this.logger.error('Expression condition error', { 
          error: error instanceof Error ? error.message : 'Unknown error',
          description 
        });
        return false;
      }
    };
  }

  /**
   * Execute a function body with parameters (event, context, rule, timestamp, utils)
   * @param functionBody - Function body code
   * @param description - Optional description
   */
  functionCode(functionBody: string, description?: string): ConditionalFunction {
    return async (event: any, context?: any) => {
      try {
        const executionContext: CodeExecutionContext = {
          event,
          context: context || {},
          rule: {},
          timestamp: new Date(),
          utils: {
            date: Date,
            math: Math,
            json: JSON,
            regex: RegExp,
            console: {
              log: (...args: any[]) => this.logger.debug('Function condition log:', args),
              warn: (...args: any[]) => this.logger.warn('Function condition warn:', args),
              error: (...args: any[]) => this.logger.error('Function condition error:', args)
            }
          }
        };

        const result = await this.codeExecutionService.executeFunction(
          functionBody, 
          executionContext
        );

        if (!result.success) {
          this.logger.error('Function condition execution failed', {
            description,
            error: result.error,
            functionBodyPreview: functionBody.substring(0, 100)
          });
          return false;
        }

        return !!result.result;

      } catch (error) {
        this.logger.error('Function condition error', { 
          error: error instanceof Error ? error.message : 'Unknown error',
          description 
        });
        return false;
      }
    };
  }

  /**
   * Use a predefined code template
   * @param templateName - Name of the template from getCodeTemplates()
   * @param parameters - Parameters to inject into the template
   */
  template(templateName: string, parameters?: Record<string, any>): ConditionalFunction {
    const templates = this.codeExecutionService.getCodeTemplates();
    const template = templates[templateName];
    
    if (!template) {
      this.logger.error('Unknown code template', { templateName });
      return () => false;
    }

    let code = template.code;
    
    // Replace parameters in template
    if (parameters) {
      Object.entries(parameters).forEach(([key, value]) => {
        const placeholder = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
        code = code.replace(placeholder, JSON.stringify(value));
      });
    }

    return this.javascript(code, `Template: ${templateName} - ${template.description}`);
  }

  /**
   * Validate JavaScript code syntax before creating condition
   * @param code - JavaScript code to validate
   */
  validateCode(code: string): { valid: boolean; error?: string } {
    return this.codeExecutionService.validateCode(code);
  }

  /**
   * Get available code templates with descriptions and examples
   */
  getAvailableTemplates(): Record<string, { description: string; code: string; example: string }> {
    return this.codeExecutionService.getCodeTemplates();
  }
}

// Export the builder instance
export const conditionBuilder = new NotificationConditionBuilder();